#!/usr/bin/env perl

###############################################################################
# Copyright (c) 2010-2013 Los Alamos National Security, LLC.
#                         All rights reserved.
#
# This program was prepared by Los Alamos National Security, LLC at Los Alamos
# National Laboratory (LANL) under contract No. DE-AC52-06NA25396 with the U.S.
# Department of Energy (DOE). All rights in the program are reserved by the DOE
# and Los Alamos National Security, LLC. Permission is granted to the public to
# copy and use this software without charge, provided that this Notice and any
# statement of authorship are reproduced on all copies. Neither the U.S.
# Government nor LANS makes any warranty, express or implied, or assumes any
# liability or responsibility for the use of this software.
################################################################################

# Author: Samuel K. Gutierrez

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use Cwd;
use File::Basename;
use File::Spec::Functions;
use POSIX qw(strftime);

my $SCRIPT_NAME = 'mpimemu-mkstats';
my $SCRIPT_VER = '0.2';

my $node_base_fn = "node-mem-usage";
my $proc_base_fn = "proc-mem-usage";

my @pre_init_node_mem_keys = (
    '^Pre-Init MemUsed',
    '^Pre-Init Cached',
    '^Pre-Init Active',
    '^Pre-Init Inactive'
);

my @post_init_node_mem_keys = (
    '^Post-Init MemUsed',
    '^Post-Init Cached',
    '^Post-Init Active',
    '^Post-Init Inactive'
);

my @pre_init_proc_mem_keys = (
    '^Pre-Init VmPeak',
    '^Pre-Init VmSize',
    '^Pre-Init VmLck',
    '^Pre-Init VmHWM',
    '^Pre-Init VmRSS',
    '^Pre-Init VmData',
    '^Pre-Init VmStk',
    '^Pre-Init VmExe',
    '^Pre-Init VmLib',
    '^Pre-Init VmPTE'
);

my @post_init_proc_mem_keys = (
    '^Post-Init VmPeak',
    '^Post-Init VmSize',
    '^Post-Init VmLck',
    '^Post-Init VmHWM',
    '^Post-Init VmRSS',
    '^Post-Init VmData',
    '^Post-Init VmStk',
    '^Post-Init VmExe',
    '^Post-Init VmLib',
    '^Post-Init VmPTE'
);

################################################################################
sub usage
{
    print
    "
Usage:
    $SCRIPT_NAME -i|-input /path/to/mpimemu/data [-o|-output /output/path]
Options:
    -i|-input        Specifies input directory (Required).
    -o|-output       Specifies output directory for generated data.
    -h|-help         Displays this message, then exits.
    -v|-version      Displays version information, then exits.
About:
    $SCRIPT_NAME reads data generated by mpimemu-run and consolidates it into
    two CSV files containing node and process information, respectively.
\n";
}

################################################################################
sub version
{
    print
    "$SCRIPT_NAME $SCRIPT_VER\n";
}

################################################################################
sub get_key_name
{
    my ($name, $with_unit) = @_;
    # remove '^'
    $name =~ s/^\^//;
    if ($with_unit) {
        $name .= " (kB)";
    }
    return $name;
}

################################################################################
sub get_filename
{
    my ($minpe, $maxpe, $basedir, $base_filename, $ext) = @_;

    my $csv_numpe_range_str = $minpe . "-" . $maxpe . 'pes';
    my $date = strftime('%m%d%Y', localtime);
    my $filename = $date . '-' . $base_filename . '-' . $csv_numpe_range_str;
    my $filepath = catfile($basedir, $filename . $ext);
    my $index = 1;

    while (-e $filepath) {
        $filepath = catfile($basedir, $filename . "-$index" . $ext);
        $index++;
    }

    return $filepath;
}

################################################################################
sub get_data_string(\@ $)
{
    my ($key_tab_ref, $file_name) = @_;
    my $data_string = '';
    my @key_tab = @$key_tab_ref;

    open(MEM_USAGE_FILE, "<", $file_name) or die $!;
    my @data = <MEM_USAGE_FILE>;

    foreach my $key (@key_tab) {
        my @line = grep(/$key/, @data);
        # make sure our grep is successful
        if (not @line) {
            close(MEM_USAGE_FILE) or die $!;
            print STDERR "  WARNING: Could not find \'" .
                         get_key_name($key, 0) . "\' in " .
                         "$file_name -- Skipping file.\n";
            return "";
        }
        my @val = split(', ', $line[0]);
        chomp(@val);
        $data_string .= ", " . $val[-1];
    }
    close(MEM_USAGE_FILE) or die $!;
    return $data_string;
}

################################################################################
sub main
{
    my $data_dir = undef;
    my $out_dir = undef;
    my $help = 0;
    my $ver = 0;
    # min and max number of PEs that we are going to process
    my $minpe = 0;
    my $maxpe = 0;

    ### parse options ###
    GetOptions(
        "help|?" => \$help,
        "version" => \$ver,
        "input=s" => \$data_dir,
        "output=s" => \$out_dir
    );
    if ($help) {
        usage();
        exit(0);
    }
    if ($ver) {
        version();
        exit(0);
    }
    if (not defined $data_dir) {
        usage();
        exit(1);
    }
    # set default output to cwd if one isn't provided
    if (not defined $out_dir) {
        $out_dir = getcwd;
    }
    ### done handling options ###

    ### construct csv headers ###
    my $node_data_str = "Number of PEs";

    foreach my $key (@pre_init_node_mem_keys, @post_init_node_mem_keys) {
        $node_data_str .= ", " . get_key_name($key, 1);
    }
    $node_data_str .= "\n";

    my $proc_data_str = "Number of PEs";

    foreach my $key (@pre_init_proc_mem_keys, @post_init_proc_mem_keys) {
        $proc_data_str .= ", " . get_key_name($key, 1);
    }
    $proc_data_str .= "\n";

    opendir(DIR, $data_dir) or die "can't open $data_dir: $!";
    # only care about file names that are one or more digits.
    # file name is numpe.
    my @uns_data_files = grep(/\d+$/, readdir(DIR));
    # if we don't have any data, then bail.
    if (not @uns_data_files) {
        closedir(DIR);
        die "Cannot find data files in: $data_dir -- Terminating.\n";
    }
    # at this point, we should have at least one valid data file.
    my @data_files = sort { $a <=> $b } @uns_data_files;

    # get min an max PEs
    $minpe = $data_files[0];
    $maxpe = $data_files[-1];

    print "- Generating CSV Report...\n";

    foreach my $file (@data_files) {
        my $cur_file = catfile($data_dir, $file);
        my @test_strs = ('', '');

        ### node data ###
        $test_strs[0] = get_data_string(@pre_init_node_mem_keys, $cur_file);
        $test_strs[1] = get_data_string(@post_init_node_mem_keys, $cur_file);

        if (not ($test_strs[0] eq "" or $test_strs[1] eq "")) {
            $node_data_str .= "$file";
            $node_data_str .= $test_strs[0];
            $node_data_str .= $test_strs[1];
            $node_data_str .= "\n";
        }

        ### proc data ###
        $test_strs[0] = get_data_string(@pre_init_proc_mem_keys, $cur_file);
        $test_strs[1] = get_data_string(@post_init_proc_mem_keys, $cur_file);

        if (not ($test_strs[0] eq "" or $test_strs[1] eq "")) {
            $proc_data_str .= "$file";
            $proc_data_str .= $test_strs[0];
            $proc_data_str .= $test_strs[1];
            $proc_data_str .= "\n";
        }
    }
    closedir(DIR);

    open(NODE_MEM_USAGE_CSV, ">",
         get_filename($minpe, $maxpe, $out_dir,
                      $node_base_fn, '.csv')) or die $!;
    open(PROC_MEM_USAGE_CSV, ">",
         get_filename($minpe, $maxpe, $out_dir,
                      $proc_base_fn, '.csv')) or die $!;
    print NODE_MEM_USAGE_CSV $node_data_str;
    print PROC_MEM_USAGE_CSV $proc_data_str;
    close(NODE_MEM_USAGE_CSV) or die $1;
    close(PROC_MEM_USAGE_CSV) or die $1;

    print "- Done Generating CSV Report...\n";
    print "- Written to: $out_dir\n";

    return 0;
}

exit(main());
