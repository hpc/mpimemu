#!/usr/bin/env perl

#
# Copyright (c) 2010-2019 Triad National Security, LLC
#                         All rights reserved.
#
# This file is part of the mpimemu project. See the LICENSE file at the
# top-level directory of this distribution.
#

# Author: Samuel K. Gutierrez

use strict;
use warnings;

use Getopt::Long;
use Pod::Usage;
use Cwd;
use File::Basename;
use File::Spec::Functions;
use POSIX qw(strftime);

my $SCRIPT_NAME = 'mpimemu-mkstats';
my $SCRIPT_VER = '0.4';

my $node_base_fn = "node-mem-usage";
my $proc_base_fn = "proc-mem-usage";

my @pre_init_node_mem_keys = (
    '^Pre-Init MemUsed',
    '^Pre-Init Cached',
    '^Pre-Init Active',
    '^Pre-Init Inactive',
    '^Pre-Init Buffers',
    '^Pre-Init MemTotal'
);

my @post_init_node_mem_keys = (
    '^Post-Init MemUsed',
    '^Post-Init Cached',
    '^Post-Init Active',
    '^Post-Init Inactive',
    '^Post-Init Buffers',
    '^Post-Init MemTotal'
);

my @pre_init_proc_mem_keys = (
    '^Pre-Init VmPeak',
    '^Pre-Init VmSize',
    '^Pre-Init VmLck',
    '^Pre-Init VmHWM',
    '^Pre-Init VmRSS',
    '^Pre-Init VmData',
    '^Pre-Init VmStk',
    '^Pre-Init VmExe',
    '^Pre-Init VmLib',
    '^Pre-Init VmPTE'
);

my @post_init_proc_mem_keys = (
    '^Post-Init VmPeak',
    '^Post-Init VmSize',
    '^Post-Init VmLck',
    '^Post-Init VmHWM',
    '^Post-Init VmRSS',
    '^Post-Init VmData',
    '^Post-Init VmStk',
    '^Post-Init VmExe',
    '^Post-Init VmLib',
    '^Post-Init VmPTE'
);

################################################################################
sub usage
{
    print
    "
Usage:
    $SCRIPT_NAME -i|-input /path/to/mpimemu/data [-o|-output /output/path]
Options:
    -i|-input        Specifies input directory (Required).
    -o|-output       Specifies output directory for generated data.
    -h|-help         Displays this message, then exits.
    -v|-version      Displays version information, then exits.
About:
    $SCRIPT_NAME reads data generated by mpimemu-run and consolidates it into
    two CSV files containing node and process information, respectively.
\n";
}

################################################################################
sub version
{
    print
    "$SCRIPT_NAME $SCRIPT_VER\n";
}

################################################################################
sub get_key_name
{
    my ($name, $with_unit) = @_;
    # remove '^'
    $name =~ s/^\^//;
    if ($with_unit) {
        $name .= " (kB)";
    }
    return $name;
}

################################################################################
sub get_cur_date_str
{
    my $date = strftime('%Y%m%d', localtime);
    return $date;
}

################################################################################
sub get_rundate
{
    # expected mpimemu output: ### date-time: 20130110-161823
    my ($file) = @_;
    my @filec = undef;
    my @date_grep = undef;
    my $date_str = "";

    open(FILE, "<", $file) or die $!;
    @filec = <FILE>;
    @date_grep = grep(/date-time:/, @filec);
    if (@date_grep) {
        if ($date_grep[0] =~ /(\d{8})/) {
            $date_str = $1;
        }
    }
    close(FILE) or die $!;

    if ($date_str eq "") {
        print STDERR "  WARNING: Could not determine run date. Using current.\n";
        $date_str = get_cur_date_str();
    }

    return $date_str;
}

################################################################################
sub get_filename
{
    my ($minpe, $maxpe, $basedir, $base_filename, $date, $ext) = @_;

    my $csv_numpe_range_str = $minpe . "-" . $maxpe . 'pes';
    my $filename = $date . '-' . $base_filename . '-' . $csv_numpe_range_str;
    my $filepath = catfile($basedir, $filename . $ext);
    my $index = 1;

    while (-e $filepath) {
        $filepath = catfile($basedir, $filename . "-$index" . $ext);
        $index++;
    }

    return $filepath;
}

################################################################################
sub get_data_string(\@ $)
{
    my ($key_tab_ref, $file_name) = @_;
    my $data_string = '';
    my @key_tab = @$key_tab_ref;

    open(MEM_USAGE_FILE, "<", $file_name) or die $!;
    my @data = <MEM_USAGE_FILE>;

    foreach my $key (@key_tab) {
        my @line = grep(/$key/, @data);
        # make sure our grep is successful
        if (not @line) {
            close(MEM_USAGE_FILE) or die $!;
            print STDERR "  WARNING: Could not find \'" .
                         get_key_name($key, 0) . "\' in " .
                         "$file_name -- Skipping file.\n";
            return "";
        }
        my @val = split(', ', $line[0]);
        chomp(@val);
        $data_string .= ", " . $val[-1];
    }
    close(MEM_USAGE_FILE) or die $!;
    return $data_string;
}

################################################################################
sub main
{
    my $data_dir = undef;
    my $out_dir = undef;
    my $help = 0;
    my $ver = 0;
    # min and max number of PEs that we are going to process
    my $minpe = 0;
    my $maxpe = 0;
    # the date string of run we are processing
    my $date = undef;
    my $found_date = 0;

    ### parse options ###
    GetOptions(
        "help|?" => \$help,
        "version" => \$ver,
        "input=s" => \$data_dir,
        "output=s" => \$out_dir
    );
    if ($help) {
        usage();
        exit(0);
    }
    if ($ver) {
        version();
        exit(0);
    }
    if (not defined $data_dir) {
        usage();
        exit(1);
    }
    # set default output to cwd if one isn't provided
    if (not defined $out_dir) {
        $out_dir = getcwd;
    }
    ### done handling options ###

    ### construct csv headers ###
    # if the TYPE metadata string ever changes, please also update mpimemu-plot
    my $node_data_str = "# TYPE: node\n";
    $node_data_str .= "Number of PEs";

    foreach my $key (@pre_init_node_mem_keys, @post_init_node_mem_keys) {
        $node_data_str .= ", " . get_key_name($key, 1);
    }
    $node_data_str .= "\n";

    # if the TYPE metadata string ever changes, please also update mpimemu-plot
    my $proc_data_str = "# TYPE: proc\n";
    $proc_data_str .= "Number of PEs";

    foreach my $key (@pre_init_proc_mem_keys, @post_init_proc_mem_keys) {
        $proc_data_str .= ", " . get_key_name($key, 1);
    }
    $proc_data_str .= "\n";

    opendir(DIR, $data_dir) or die "can't open $data_dir: $!";
    # only care about file names that are one or more digits.
    # file name is numpe.
    my @uns_data_files = grep(/^\d+$/, readdir(DIR));
    # if we don't have any data, then bail.
    if (not @uns_data_files) {
        closedir(DIR);
        die "Cannot find data files in: $data_dir -- Terminating.\n";
    }
    # at this point, we should have at least one valid data file.
    my @data_files = sort { $a <=> $b } @uns_data_files;

    # get min an max PEs
    $minpe = $data_files[0];
    $maxpe = $data_files[-1];

    print "- Generating CSV Reports...\n";

    foreach my $file (@data_files) {
        my $cur_file = catfile($data_dir, $file);
        my @test_strs = ('', '');

        ### node data ###
        $test_strs[0] = get_data_string(@pre_init_node_mem_keys, $cur_file);
        $test_strs[1] = get_data_string(@post_init_node_mem_keys, $cur_file);

        if (not ($test_strs[0] eq "" or $test_strs[1] eq "")) {
            # looks like valid data, so try to get the date string
            if (!$found_date) {
                $date = get_rundate($cur_file);
                $found_date = 1;
            }
            $node_data_str .= "$file";
            $node_data_str .= $test_strs[0];
            $node_data_str .= $test_strs[1];
            $node_data_str .= "\n";
        }

        ### proc data ###
        $test_strs[0] = get_data_string(@pre_init_proc_mem_keys, $cur_file);
        $test_strs[1] = get_data_string(@post_init_proc_mem_keys, $cur_file);

        if (not ($test_strs[0] eq "" or $test_strs[1] eq "")) {
            $proc_data_str .= "$file";
            $proc_data_str .= $test_strs[0];
            $proc_data_str .= $test_strs[1];
            $proc_data_str .= "\n";
        }
    }
    closedir(DIR);

    open(NODE_MEM_USAGE_CSV, ">",
         get_filename($minpe, $maxpe, $out_dir,
                      $node_base_fn, $date, '.csv')) or die $!;
    open(PROC_MEM_USAGE_CSV, ">",
         get_filename($minpe, $maxpe, $out_dir,
                      $proc_base_fn, $date, '.csv')) or die $!;
    print NODE_MEM_USAGE_CSV $node_data_str;
    print PROC_MEM_USAGE_CSV $proc_data_str;
    close(NODE_MEM_USAGE_CSV) or die $1;
    close(PROC_MEM_USAGE_CSV) or die $1;

    print "- Done Generating CSV Reports...\n";
    print "- Written to: $out_dir\n";

    return 0;
}

exit(main());
