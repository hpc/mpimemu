#!/usr/bin/env python

###############################################################################
# Copyright (c)      2017 Los Alamos National Security, LLC.
#                         All rights reserved.
###############################################################################

import os
import sys
import imp
import time
import subprocess
import argparse


###############################################################################
class RunConfiguration:
    def __init__(self, arg_dict):
        self.args = arg_dict
        self.config_path = self.args['config']
        self.mod_name = self.get_mod_name(self.config_path)
        self.user_config_mod = self.import_name(
            self.mod_name,
            self.config_path
        )
        self.user_config = self.user_config_mod.MemnesiaStudyConfig()
        self.output_path = self.get_output_path()

    def get_output_path(self):
        outp = '{}/{}'.format(self.args['output'], self.args['name'])
        return outp

    def import_name(self, mod_name, config_path):
        mod = None
        try:
            mod = imp.load_source(mod_name, config_path)
        except ImportError as e:
            print('Cannot import configuration file: {}'.format(e.message))
            return None
        return mod

    def get_mod_name(self, config_path):
        file_name = os.path.basename(config_path)
        if (file_name.endswith('.py')):
            return file_name[:-3]


class Runner:
    def __init__(self, run_config):
        self.run_config = run_config
        self.user_config = self.run_config.user_config
        self.setup_env()
        self.make_data_dirs()

    def setup_env(self):
        os.environ["MEMNESIA_REPORT_OUTPUT_PATH"] = self.run_config.output_path

    def make_data_dirs(self):
        os.makedirs(self.run_config.output_path, 0o750)

    def run(self, with_trace=True, test=False):
        print('# Running the following Study')
        self.user_config.emit_config(sys.stdout)

        numpe_runcmd = self.user_config.numpe_runcmd
        ld_preload = 'LD_PRELOAD={}'.format(self.run_config.args['trace_lib'])

        for numpe, appcmd in sorted(numpe_runcmd.iteritems()):
            os.environ['MEMNESIA_REPORT_NAME'] = '{}PE'.format(numpe)
            rcmd = appcmd
            if with_trace:
                rcmd = '{} {}'.format(ld_preload, appcmd)

            if (test):
                print('run: {}'.format(rcmd))
                continue
            # Else actually run the thing.
            print('')
            for i in range(0, 2):
                print('')
            print('Running: {}'.format(rcmd))

            p = subprocess.Popen(
                    rcmd,
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT
                )
            # Show progress.
            while (True):
                o = p.stdout.readline()
                sys.stdout.write(o)

                if o == '' and p.poll() is not None:
                    break

            retval = p.wait()
            if (retval != 0):
                print('RUN FAILURE: {}'.format(rcmd))
            # Take the day off, boss.
            time.sleep(2)


###############################################################################
def check_args(parser, arg_dict):
    configf = arg_dict['config']
    base_outp = arg_dict['output']
    res_name = arg_dict['name']
    full_out = '{}/{}'.format(base_outp, res_name)
    trace_lib = arg_dict['trace_lib']

    if not os.path.isfile(configf) or not configf.endswith('.py'):
        print("'{}' is not a config file. Cannot continue.".format(configf))
        parser.print_help()
        exit(os.EX_USAGE)

    if not os.path.isdir(base_outp):
        print("'{}' is not a directory. Cannot continue.".format(base_outp))
        parser.print_help()
        exit(os.EX_USAGE)

    if os.path.isdir(full_out):
        print("'{}' already exists. Cannot continue.".format(full_out))
        parser.print_help()
        exit(os.EX_USAGE)

    if not os.path.isdir(base_outp):
        print("'{}' is not a directory. Cannot continue.".format(base_outp))
        parser.print_help()
        exit(os.EX_USAGE)

    if not os.path.isfile(trace_lib):
        print("'{}' is not a file. Cannot continue.".format(trace_lib))
        parser.print_help()
        exit(os.EX_USAGE)


###############################################################################
def main(argv=None):
    if argv is None:
        argv = sys.argv

    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--config',
        type=str,
        help='Path to user configuration file.',
        required=True
    )
    parser.add_argument(
        '--output',
        type=str,
        help='Base path to result output.',
        required=True
    )
    parser.add_argument(
        '--name',
        type=str,
        help='Result output directory name.',
        required=True
    )
    parser.add_argument(
        '--trace-lib',
        type=str,
        help='Path to memneisa trace library.',
        required=True
    )

    arg_dict = vars(parser.parse_args())

    check_args(parser, arg_dict)

    runner = Runner(RunConfiguration(arg_dict))
    with_trace = True
    test = False
    runner.run(with_trace, test)

    return os.EX_OK


###############################################################################
###############################################################################
###############################################################################
if __name__ == "__main__":
    sys.exit(main())
