#!/usr/bin/env python

###############################################################################
# Copyright (c)      2017 Los Alamos National Security, LLC.
#                         All rights reserved.
###############################################################################

import os
import sys
import operator
import matplotlib.pyplot as plt
import numpy as np
import collections


###############################################################################
class Util:
    @staticmethod
    def btomb(b):
        return b * 1024 * 1024


###############################################################################
class RunMetadata:
    def __init__(self, data_path):

        self.data = {
            'Application Name': '',
            'Hostname': '',
            'MPI_COMM_WORLD Rank': long(0),
            'Number of Operation Captures Performed': long(0),
            'Number of Memory Operations Recorded': long(0),
            'Number of Allocation-Related Operations Recorded': long(0),
            'Number of Deallocation-Related Operations Recorded': long(0),
            'Number of MPI Library PSS Samples Collected': long(0),
            'Number of Application PSS Samples Collected': long(0),
            'High Memory Usage Watermark (MPI) (MB)': float(0),
            'High Memory Usage Watermark (Application + MPI) (MB)': float(0)
        }

        with open(data_path, 'r') as f:
            lines = [x.strip('\n') for x in f.readlines()]

            assert(lines[0] == '# [Run Info Begin]')

            lidx = 1
            meta_lines = []
            while True:
                if lines[lidx] == '# [Run Info End]':
                    break
                meta_lines.append(lines[lidx].strip('# '))
                lidx += 1

            for ml in meta_lines:
                kv = [x.strip(' ') for x in ml.split(':')]
                assert(len(kv) == 2)
                key = kv[0]
                val_str = kv[1]
                if key not in self.data:
                    print("ERROR: '{}' not a recognized key...".format(key))
                    assert(False)
                self.data[key] = self.cast(type(self.data[key]), val_str)

    def cast(self, val_type, string):
        return val_type(string)

    @staticmethod
    def emit_stats(meta_list):
        header = '# Run Statistics '
        print('{}{}'.format(header, '#' * (80 - len(header))))

        print('# Application: {}'.format(
            meta_list[0].data['Application Name'])
        )

        print('# Number of Output Files Analyzed: {}'.format(len(meta_list)))

        for kprefix in ['Number of', 'High Memory Usage Watermark']:
            stat_keys = [k for k in meta_list[0].data.keys()
                         if k.startswith(kprefix)]
            RunMetadata.emit_min_max_aves(meta_list, stat_keys)

    @staticmethod
    def emit_min_max_aves(meta_list, keys):
        for k in keys:
            print('# {}'.format(k))

            vals = [meta.data[k] for meta in meta_list]

            minidx, minval = min(enumerate(vals), key=operator.itemgetter(1))
            maxidx, maxval = max(enumerate(vals), key=operator.itemgetter(1))

            min_where = meta_list[minidx].data['Hostname']
            max_where = meta_list[maxidx].data['Hostname']
            ave = RunMetadata.mean(vals)

            print('- Min: {}, Who: {}, Where: {}'.format(
                minval, minidx, min_where)
            )
            print('- Max: {}, Who: {}, Where: {}'.format(
                maxval, maxidx, max_where)
            )
            print('- Ave: {0:0.3f}'.format(ave))

    @staticmethod
    def mean(num_lst):
        return float(sum(num_lst)) / max(len(num_lst), 1)


###############################################################################
class TimeSeries:
    def __init__(self):
        self.data = {
            'times': [],
            'svals': []
        }

    def push(self, time, samp_val):
        self.data['times'].append(time)
        self.data['svals'].append(samp_val)

    def get(self, key):
        assert(key in self.data)
        return self.data[key]


###############################################################################
class Experiment:
    def __init__(self, log_path):
        self.log_path = log_path
        self.log_files = self.get_log_files(log_path)
        self.run_meta = self.get_run_meta()
        '''
        Two level dict maps rank to usage type to time series.
        '''
        self.rank_to_time_series = collections.defaultdict(dict)

        self.data_sanity()

        RunMetadata.emit_stats(self.run_meta)

    def get_num_species(self):
        return len(self.rank_to_time_series)

    def get_log_files(self, log_path):
        (_, _, file_names) = os.walk(log_path).next()
        logs = [f for f in file_names if f.endswith('.mmcb')]
        return self.sort_human(logs)

    def get_run_meta(self):
        meta = []
        for log in self.log_files:
            data_path = '{}/{}'.format(self.log_path, log)
            meta.append(RunMetadata(data_path))
        return meta

    def sort_human(self, lst):
        return sorted(lst, key=lambda x: '{0:0>8}'.format(x).lower())

    def data_sanity(self):
        app_name = None
        for idx, meta in enumerate(self.run_meta):
            cur_app_name = meta.data['Application Name']
            if app_name is None:
                app_name = cur_app_name
            elif app_name != cur_app_name:
                print("ERROR: Application name mismatch!")
                assert(False)
            rank = meta.data['MPI_COMM_WORLD Rank']
            assert(rank == idx)

    def crunch(self):
        for log in self.log_files:
            rank = int(log.split('.')[0])
            fpath = '{}/{}'.format(self.log_path, log)

            with open(fpath, 'r') as f:
                content = [x.strip('\n') for x in f.readlines()
                           if not x.strip().startswith('#')]

                ts = {
                    'MPI_MEM_USAGE': TimeSeries(),
                    'APP_MEM_USAGE': TimeSeries()
                }

                for l in content:
                    ldata = l.split(' ')
                    dtype = ldata[0]
                    dtime = float(ldata[1])
                    dmem = long(ldata[2])
                    ts[dtype].push(dtime, dmem)

                self.rank_to_time_series[rank] = ts


###############################################################################
class Colorer:
    def __init__(self, n_colors):
        self.n_colors = n_colors
        self.color_idx = 0
        self.pvalues = np.logspace(-0.1, 0, n_colors)
        self.pmin = self.pvalues[0]
        self.pmax = self.pvalues[-1]

    def norm(self, pval):
        return (pval - self.pmin) / float(self.pmax - self.pmin)

    def get_color(self):
        c = plt.cm.copper(
            self.norm(self.pvalues[self.color_idx % self.n_colors])
        )
        self.color_idx += 1
        return c


###############################################################################
class Plotter:
    def __init__(self, experiments_to_plot):
        self.fname = self.get_usable_file_name('mem-usage-over-time', 'pdf')
        self.experiments = experiments_to_plot
        self.numpes = set()
        self.fig, self.ax = plt.subplots()
        self.line_style = 'solid'
        self.colorer = None

    def plot(self):
        ''' Color maps setup '''
        num_colors = max([e.get_num_species() for e in self.experiments])
        self.colorer = Colorer(num_colors)

        print('plotting to {}'.format(self.fname))

        for e in self.experiments:
            for rank, ts in sorted(e.rank_to_time_series.iteritems()):
                for ts_type, tsi in ts.iteritems():
                    self.add_plot(rank, tsi)

        plt.grid(True)
        plt.axis('tight')

        plt.title('Memory Usage Over Time')
        self.ax.set_ylabel('Memory Usage (MB)', fontsize=16)
        self.ax.set_xlabel('Wall Time Since Initialization (s)', fontsize=16)

        '''
        scalf = 1.05
        plt.xlim(0, lens * 1.10)
        plt.ylim(min(self.cg_time) / scalf, (max(self.cg_time) * scalf))
        '''
        '''
        plt.legend(loc=2)
        '''

        self.fig.savefig(
            self.fname,
            format='pdf',
            bbox_inches='tight',
            pad_inches=0.03
        )

    def add_plot(self, rank, time_series):
        x = time_series.get('times')
        x0 = x[0]
        x = [i - x0 for i in x]

        y = map(Util.btomb, time_series.get('svals'))

        #
        lbl = 'Rank {}'.format(rank)
        clr = self.colorer.get_color()
        #
        plt.plot(
            x, y,
            label=lbl,
            linestyle=self.line_style,
            color=clr,
            alpha=0.75
        )
        '''
        self.ax.fill_between(
            range(len(y)), 0, y,
            interpolate=True, color=clr, alpha=0.3
        )
        '''

    def get_usable_file_name(self, name, extension):
        fidx = 1
        cwd = os.getcwd()
        target_fname = '{}/{}.{}'.format(cwd, name, extension)
        while (os.path.isfile(target_fname)):
            target_fname = '{}/{}-{}.{}'.format(cwd, name, fidx, extension)
            fidx += 1

        return target_fname


###############################################################################
def usage():
    print('usage: plot-xhpcg-weak [DATADIR]...')


###############################################################################
def check_args(argv):
    if len(argv) < 2:
        usage()
        exit(os.EX_USAGE)

    for arg in argv[1:]:
        if not os.path.isdir(arg):
            print("'{}' is not a directory. Cannot continue.".format(arg))
            usage()
            exit(os.EX_USAGE)


###############################################################################
def process_experiment_data(data_dirs):
    experiments = []

    for data_dir in data_dirs:
        print('# Processing files in {}'.format(data_dir))
        e = Experiment(data_dir)
        e.crunch()
        experiments.append(e)

    return experiments


###############################################################################
def main(argv=None):
    if argv is None:
        argv = sys.argv

    check_args(argv)

    experiments = process_experiment_data(argv[1:])

    plotter = Plotter(experiments)
    plotter.plot()

    return os.EX_OK


###############################################################################
###############################################################################
###############################################################################
if __name__ == "__main__":
    sys.exit(main())
